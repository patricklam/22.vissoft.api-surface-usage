\label{sec:collecting-data}
Our goal is to visualize interactions between different software components---between
clients and libraries, and between libraries and other libraries. We now explain
how we collect static and dynamic information about software behaviour.

\paragraph{Static information} ???

\paragraph{Dynamic information} We collect dynamic data by running client
test suites under instrumentation. 
The instrumentation records API
uses which cross client/library boundaries, as well as library/library boundaries
for libraries that are transitively used. We use
Javassist~\cite{chiba00:_load_struc_reflec_java} to perform the
instrumentation and then the build system of each project (Maven or Gradle) to run its
tests. Figure~\ref{fig:workflow} summarizes our instrumentation and
data capture workflow. We next describe our instrumentation implementation in detail.

We identify interactions across the client/library boundaries by
inspecting JAR files of each software component to obtain a list of
classes for every component. We associate classes and their members to
components based on these lists. \todo{is this still true?}

\begin{figure*}[h]
 \begin{center}
\resizebox{0.7\textwidth}{!}{
  \begin{tikzpicture}
    \node[block] (client) {client};
    \node[block,below=1cm of client] (library) {library};

    \draw (library) -- node[left] (depends) {depends on} (client);

    \node[above left=.75em of client] (ja) {\begin{minipage}{7em} modify \\to use Javassist \end{minipage}};
    \draw[-Latex] (ja) -> (client);
    \draw[-Latex] (ja) to [->,bend right=35] (library.west);

    \node[block, above right=2em of client,xshift=-2em] (olib) {other library};
    \draw (client) -- node[right,xshift=.1em] (also) {also depends on} (olib);

    \node[oval,right=of depends] (test) {maven/gradle: run tests};

    \draw[-Latex] (client) to [->,bend left=15] (test);

    \node[block, right=10em of client] (output) {test output};
    \node[block, right=10em of library] (raw) {raw API usage info};

    \draw[-Latex] (test) to (output);
    \draw[-Latex] (test) to (raw);

    \node[oval, right=of raw] (Py) {Python scripts};
    \draw[-Latex] (raw) to (Py);

    \node[block, right=1em of Py] (viz) {D3 visualizations};
    \draw[-Latex] (Py) to (viz);
  \end{tikzpicture}
}
  \caption{Our instrumentation workflow. We modify existing project infrastructure to instrument clients and to run their test suites, producing raw data, which we process with our Python scripts to create D2 visualizations.}
  \label{fig:workflow}
 \end{center}
\end{figure*}


At every invoke instruction in every
loaded method which transfers control between the client and the
library, we add code to record that invoke by incrementing a counter.
We handle both static and virtual (including special, virtual,
interface, and dynamic) calls. Crossing the client/library boundary
includes callbacks from the library to the client as well as the conventional
calls from the client to the library. 

We also record field accesses (direct and reflective), dynamic proxies
and reflective calls, Java annotations, implementations,
instantiations, and casts.
