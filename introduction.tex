\section{Introduction}
\label{sec:introduction}

The long-term aspiration for software component reuse has finally arrived. This vision---of a component ecosystem enabling ubiquitous reuse and economies of scale---was first proposed over 50 years ago~\cite{mcilroy1968mass} and has finally become reality. Today's applications are largely built from existing components (with one major exception being embedded or safety-critical systems). A key contributor to this shift was the emergence of open source component repositories  such as Maven and npm: automated dependency resolution lowers the barriers for using third-party components, and developers can easily include components from them in their projects. The size and growth rate of these repositories is staggering.

However, there are still no silver bullets in software engineering~\cite{frederick87:_no_silver_bullet}. Component repositories are certainly not silver bullets, and their use comes with important trade-offs. The number of dependencies used by modern software has exploded, and so has their complexity~\cite{kikas2017structure,benelallam2019maven}: deeper, transitive dependencies are now common, components are upgraded more frequently, and developers increasingly struggle to deal with issues arising from those changes, such as: (1) dealing with conflicting versions of the same component (also known as dependency hell) and dealing with supply chain vulnerabilities of deep dependencies (often notified by bots creating pull requests); (2) new issues around security and resilience of the software supply chains, e.g. problems with changes to commodity components (as in the infamous left-pad incident~\cite{collins16:_how}) and novel attack patterns like typosquatting; and, (3) the use of unnecessary, bloated, and trivial dependencies~\cite{abdalkareem2017developers,soto2021comprehensive}.

So, components are revolutionary but bring new problems. Let's consider one problem: breaking changes. \textit{Potentially} breaking changes in library APIs are common~\cite{dietrich2014broken,raemaekers2014semantic}. However, any library change is only potentially breaking; does it \textit{actually} break any particular client? Only if a client uses a specific component API with an incompatible change.  

Yet, under plain Java (i.e. no runtime containers) and considering reflection, the API surface of any component is huge. Essentially: every method can be called, and every field can be read and written. Our research aims to answer the question: is the API surface huge in practice? Or, ought we better control component use? There are clear benefits in restricting the API surface: such restrictions can facilitate analyses that can calculate whether breaking changes are \textit{likely} to actually break clients.  Or, in terms of precision, added restrictions to the API surface would facilitate breakage analyses with fewer false positives (i.e., increased precision). 

As a second problem, consider the detection of vulnerabilities in dependencies. Detection is relatively straight-forward: compute the transitive closure of all dependencies, and cross-reference the transitive dependencies with vulnerability databases like CVEs. Tools like \textit{snyk} and \textit{dependabot} are based on this general idea. Some languages and build systems like npm have built-in language-specific support (\textit{npm audit}). The problem is again precision---listing something as a dependency does not mean that all of its functionality is used. So, if dependencies are sufficiently large and deep, a conservative approach inevitably results in false positives. Indeed, Elizalde Zapata et al~\cite{elizalde18:_towar_smoot_librar_migrat} found that 73\% of their studied clients with theoretically vulnerable dependencies were not actually at risk from CVEs in those dependencies, and Chinthanet et al~\cite{chinthanet20:_code_based_vulner_detec_node} implemented a code-based vulnerability detection tool for Node.js applications. Like the boy who cried wolf, false positives can lead to a potentially devastating impact on application security when true positives start being ignored, as demonstrated in the infamous Equifax incident~\cite{luszcz2018apache}. Sadowski et al~\cite{sadowski2018lessons}, among others, also cite the necessity for low false positive rates in developer tools.

The basic problem is well-known. In the history of Java (and other languages), several constructs enable component developers to better define and enforce the API surface, including access modifiers, modules, and bundles restricting access to packages, and packaging of components that only expose ``services'', i.e. instantiable classes implementing some abstract type that specifies the service. However, these restrictions always have to compete with the need to provide runtime introspection and code generation features.  Such features are needed to write generic software that can adapt to its usage context. A good example is the automated mapping of domain models to persistency (XML, JSON, RDMBMS, etc).

%  This is often part of another successful trend in modern software engineering---convention over configuration---where services are inferred based on implicit interfaces defined by conventions. 

%In a sense, this has created an arms race:  technologies trying to control APIs versus techniques allowing software to bypass restrictions. This is the space that developers have to navigate when writing modern software.

This paper aims to take a snapshot of where current software practices stand: we investigate how APIs are used and misused. 
We intend to make our code and data available with the camera-ready version of this paper.

Our contributions include:
\begin{itemize}
\item a classification of API uses and mis-uses along four dimensions (Section~\ref{sec:classification}), with examples (Section~\ref{sec:api-usage-examples});
\item a tool to instrument Java code and collect dynamic instrumentation data about API uses in practice (Section~\ref{sec:technique});
\item an empirical study (Section~\ref{sec:results}) to investigate a collection of 11 libraries and 38 clients: (1) API mis-uses exercised during client tests; (2) sizes and overlaps of the API surfaces of the libraries used by the client test suites.
\end{itemize}

%To expand on our aims, we aim to characterize (1) API uses of libraries that are not anticipated by the library developers (``mis-uses'') as well as (2) the empirical extent of API uses by their clients (``API surfaces''). 

{\bf Findings.} Our results indicate that API mis-uses are generally rare: developers respect modularity declarations and seldom use reflection to bypass access modifiers (with serialization as a key exception). On the other hand, clients use widely varying portions of their libraries.

Actionable outcomes, which we discuss in Section~\ref{sec:discussion}, include guidance to API designers, based on the fact that API usages are sparse, as well as suggestions for tool designers.
